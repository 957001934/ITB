# 基于Scapy的TCP/UDP端口扫描
### 基本原理
##### TCP半连接端口扫描 
TCP半连接扫描，该过程不会和服务端建立完整的连接，首先客户端会发送一个带有SYN标识和端口号的TCP数据包给服务器，如果服务器这个端口是开放的，则会接受这个连接并返回一个带有SYN和ACK标识的数据包给客户端，随后客户端会返回带有RST标识的数据包。如果目标端口处于关闭状态，则服务端会返回一个RST标识的数据包。  
通过Scapy模拟发包收包，并对包进行解析，从而判断端口是否开启

##### TCP全连接端口扫描
TCP全连接扫描，此过程客户端会和服务端进行完整的3次握手。首先客户端会发送一个带有SYN标识和端口号的TCP数据包给服务器，如果服务器这个端口是开放的，则会接受这个连接并返回一个带有SYN和ACK标识的数据包给客户端，随后客户端会发送带有ACK和RST标识的数据包给服务端，此时客户端与服务器建立了连接。如果端口不开放则会返回一个RST标识的数据包给客户端。  
通过Scapy模拟发包收包，并对包进行解析，从而判断端口是否开启。

##### UDP端口扫描原理
利用ICMP端口不可达报文进行扫描。当一个UDP端口接收到一个UDP数据报时，如果它是关闭的，就会给源端发回一个ICMP端口不可达数据报；如果它是开放的，那么就会忽略这个数据报，也就是将它丢弃而不返回任何的信息，说明该端口是开放的或者该消息被过滤了。   
* 缺点：扫描结果的可靠性不高。因为当发出一个UDP数据报而没有收到任何的应答时，有可能因为这个UDP端口是开放的，也有可能是因为这个数据报在传输过程中丢失了。另外，扫描的速度很慢。原因是在RFC1812的中对ICMP错误报文的生成速度做出了限制。例如Linux就将ICMP报文的生成速度限制为每4秒钟80个，当超出这个限制的时候，还要暂停1/4秒。    
Nmap的UDP扫描也是采用的这个原理，所以从原理上限制了它不能加速（多线程无效），所以一旦发报速度加快，误报率相当高。

### 测试结果对比
##### TCP端口扫描
> env：128线程，65535个端口  
  
| 方法    | 系统   |连接方式	 | 平均时间(min） |	平均准确率 |  
| :-----: | :-----: | :-----: | :-----: | :-----: |  
|Scapy	| Windows |全连接 |6	| 26/25 | 
|	|         |半连接 |6	| 26/25 |
|	|Linux	  |全连接 |5       |100% |
|	|	  |半连接 |5	|100% |
|Nmap	|Windows  |全连接 |20+	|未测 |
|	|	  |半连接 |20+	|未测|
|	|Linux	  |全连接 |20+	|未测|
|	|	  |半连接 |20+	|未测|

##### UDP端口扫描
> env：100个端口，Linux
  
| 方法 |是否使用多线程|平均时间（s）| 误判率 | 备注 |  
| :-----: | :-----: | :-----: | :-----: | :-----: |  
|Scapy+Nmap	| 使用多线程(128)|40+ |80%| 由于ICMP的发送速度限制，一旦发送速率过快就会出现大量的误报 | 
|	| 单线程  |140+|接近0|  限制发送速度（1s）|
|Nmap	|使用多线程(128)  |40+ |非常高|CPU占用高，卡顿 |
|	|	单线程  |110+ |接近0	||

### 采取方案
Scapy多线程进行TCP端口扫描，Nmap单线程进行UDP端口扫描

### 主要功能点
* TCP、UDP多线程同时扫描
* 使用日志log线程单独打印进度条
* 指定网卡发包
* 检测静态ARP协议

### 实机测试数据
##### TCP端口扫描
> env：64线程，65535个端口，靶机：172.16.100.51  WIFI:TICPb

| 网络   |  系统   | 连接方式 | 平均时间(s）       | 平均准确率 |
| :---: | :-----: | :------: | :------------:  | :--------: |
| 网线   | Windows |  全连接  |       311 s       |   20/20    |
|       |         |  半连接  |       310 s        |   20/20     |
|       |  Linux  |  全连接  |       248 s        |    30/30    |
|       |         |  半连接  |      248 s        |    30/30   | 
|WIFI   | Windows |  全连接  |       800s        |        |
|       |         |  半连接  |       944s            |       |
|       |  Linux  |  全连接  |       402s     |     23  |
|       |         |  半连接  |       368s       |   23   | 


##### UDP端口扫描
> env：100个端口，Linux，方法：libnamp

|    网络环境  | 系统     | 平均时间（s） | 平均准确率    |                            备注                    |
| :--------: | :-----: | :-----------: | :----: | :------------------------------------------------: |
| 网线        | Windows   |      216 s    | 10/10    |          windows扫描结果有时不太稳定          |
|            |  Linux    |     106 s     |  1/1  |                                                 |
| WIFI       |  Windows |       144 s    |    |                  windows扫描结果有时不太稳定                                |
|            |   Linux   |      114s   |  1/1   |                                                 |

##### TCP、 UDP同时扫描
> env:65535个TCP端口，100个UDP端口  

|    网络环境  | 系统     | 平均时间（s） | 准确率    |                            备注                    |
| :--------: | :-----: | :-----------: | :----: | :------------------------------------------------: |
| 网线        | Windows   |       316 s       |  20/20 10/10  |                                                   |
|            |  Linux    |     248s     |   30/30 1/1  |                                        |
| WIFI       |  Windows |        966s   |     |                                                  |
|            |   Linux   |      371s     |  23,22 1/1   |                                                 |

##### Scapy底层理解
Scapy的发包过程是需要构建包，可以选择构建二层（数据链路层）发包也可以选择构建三层（网络层）发包，如果只选择三层发包，scapy会为你填充默认的底层包字段信息，比如广播MAC等，这在一些场景下可能导致发包失败。若是在二层发包，需指定目标MAC地址，需要考虑和鉴别静态ARP的情况。若不指定MAC，scapy会为你自动填充网关的MAC地址，交由网关来进行发送。

##### 发包及处理逻辑
![发包及处理逻辑](https://github.com/957001934/PortScan/blob/main/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E9%80%BB%E8%BE%91.png)
