# 基于Scapy的TCP/UDP端口扫描
### 基本原理
##### TCP半连接端口扫描 
TCP半连接扫描，该过程不会和服务端建立完整的连接，首先客户端会发送一个带有SYN标识和端口号的TCP数据包给服务器，如果服务器这个端口是开放的，则会接受这个连接并返回一个带有SYN和ACK标识的数据包给客户端，随后客户端会返回带有RST标识的数据包。如果目标端口处于关闭状态，则服务端会返回一个RST标识的数据包。  
通过Scapy模拟发包收包，并对包进行解析，从而判断端口是否开启

##### TCP全连接端口扫描
TCP全连接扫描，此过程客户端会和服务端进行完整的3次握手。首先客户端会发送一个带有SYN标识和端口号的TCP数据包给服务器，如果服务器这个端口是开放的，则会接受这个连接并返回一个带有SYN和ACK标识的数据包给客户端，随后客户端会发送带有ACK和RST标识的数据包给服务端，此时客户端与服务器建立了连接。如果端口不开放则会返回一个RST标识的数据包给客户端。  
通过Scapy模拟发包收包，并对包进行解析，从而判断端口是否开启。

##### UDP端口扫描原理
利用ICMP端口不可达报文进行扫描。当一个UDP端口接收到一个UDP数据报时，如果它是关闭的，就会给源端发回一个ICMP端口不可达数据报；如果它是开放的，那么就会忽略这个数据报，也就是将它丢弃而不返回任何的信息，说明该端口是开放的或者该消息被过滤了。   
* 缺点：扫描结果的可靠性不高。因为当发出一个UDP数据报而没有收到任何的应答时，有可能因为这个UDP端口是开放的，也有可能是因为这个数据报在传输过程中丢失了。另外，扫描的速度很慢。原因是在RFC1812的中对ICMP错误报文的生成速度做出了限制。例如Linux就将ICMP报文的生成速度限制为每4秒钟80个，当超出这个限制的时候，还要暂停1/4秒。    
Nmap的UDP扫描也是采用的这个原理，所以从原理上限制了它不能加速（多线程无效），所以一旦发报速度加快，误报率相当高。

### 测试结果对比
##### TCP端口扫描
> env：128线程，65535个端口  
  
| 方法    | 系统   |连接方式	 | 平均时间(min） |	平均准确率 |  
| :-----: | :-----: | :-----: | :-----: | :-----: |  
|Scapy	| Windows |全连接 |6	| 26/25 | 
|	|         |半连接 |6	| 26/25 |
|	|Linux	  |全连接 |5       |100% |
|	|	  |半连接 |5	|100% |
|Nmap	|Windows  |全连接 |20+	|未测 |
|	|	  |半连接 |20+	|未测|
|	|Linux	  |全连接 |20+	|未测|
|	|	  |半连接 |20+	|未测|

##### UDP端口扫描
> env：100个端口，Linux
  
| 方法 |是否使用多线程|平均时间（s）| 误判率 | 备注 |  
| :-----: | :-----: | :-----: | :-----: | :-----: |  
|Scapy+Nmap	| 使用多线程(128)|40+ |80%| 由于ICMP的发送速度限制，一旦发送速率过快就会出现大量的误报 | 
|	| 单线程  |140+|接近0|  限制发送速度（1s）|
|Nmap	|使用多线程(128)  |40+ |非常高|CPU占用高，卡顿 |
|	|	单线程  |110+ |接近0	||

### 采取方案
Scapy多线程进行TCP端口扫描，Nmap单线程进行UDP端口扫描
